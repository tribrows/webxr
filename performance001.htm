<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js High Performance WebXR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; color: white; font-family: sans-serif; }
        canvas { width: 100%; height: 100%; display: block; }
        .overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; }
        .badge { background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; border: 1px solid #333; backdrop-filter: blur(8px); margin-bottom: 8px; }
        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; }
        button { background: #222; border: 1px solid #444; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.2s; color: white; }
        button:hover { background: #00e5ff; color: #000; border-color: #00e5ff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #msgBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #991b1b; padding: 20px; border-radius: 8px; display: none; z-index: 100; border: 1px solid #ef4444; }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-gl { background-color: #f59e0b; } /* Orange for GL */
        .status-gpu { background-color: #10b981; } /* Green for GPU */
    </style>
</head>
<body>

    <div id="msgBox">
        <p id="msgText"></p>
        <button onclick="document.getElementById('msgBox').style.display='none'" class="mt-4 text-xs">Close</button>
    </div>

    <div class="overlay">
        <div class="badge">
            <h1 class="text-xl font-bold text-cyan-400">Three.js Performance Test</h1>
            <p class="text-xs opacity-70">InstancedMesh & Matrix Optimization</p>
        </div>
        <div id="stats" class="badge font-mono text-sm">
            Initializing...
        </div>
        <div class="badge font-mono text-xs pointer-events-auto">
             <span id="rendererIndicator" class="status-dot status-gl"></span>
             <span id="rendererName">WebGL 2</span>
        </div>
    </div>

    <div class="controls">
        <button id="xrBtn">CHECKING XR...</button>
        <button id="addGeometry">ADD 1,000 CUBES</button>
        <button id="toggleBackend">SWITCH TO WEBGPU</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let mesh; // The InstancedMesh
        let currentCount = 0;
        const maxCount = 100000; // Pre-allocate buffer for performance
        const dummy = new THREE.Object3D(); // Helper for matrix calculations
        let isWebGPU = false;

        // UI Elements
        const statsEl = document.getElementById('stats');
        const xrBtn = document.getElementById('xrBtn');
        const msgBox = document.getElementById('msgBox');
        const msgText = document.getElementById('msgText');
        const rendererName = document.getElementById('rendererName');
        const rendererIndicator = document.getElementById('rendererIndicator');
        const toggleBackendBtn = document.getElementById('toggleBackend');

        const showMessage = (text) => {
            msgText.innerText = text;
            msgBox.style.display = "block";
        };

        // Initialize based on URL params
        init();

        async function init() {
            // 0. Check Backend Preference
            const urlParams = new URLSearchParams(window.location.search);
            isWebGPU = urlParams.get('backend') === 'webgpu';

            // UI Update based on backend
            if (isWebGPU) {
                rendererName.innerText = "WebGPU (Experimental)";
                rendererIndicator.className = "status-dot status-gpu";
                toggleBackendBtn.innerText = "SWITCH TO WEBGL";
            } else {
                rendererName.innerText = "WebGL 2";
                rendererIndicator.className = "status-dot status-gl";
                toggleBackendBtn.innerText = "SWITCH TO WEBGPU";
            }

            // Toggle Button Logic
            toggleBackendBtn.onclick = () => {
                const newBackend = isWebGPU ? 'webgl' : 'webgpu';
                urlParams.set('backend', newBackend);
                window.location.search = urlParams.toString();
            };

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 20, 100);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 5, 20);

            // 2. Renderer Setup (Conditional)
            try {
                if (isWebGPU) {
                    // Dynamic import to avoid loading errors if not needed or supported
                    const { default: WebGPURenderer } = await import('three/addons/renderers/webgpu/WebGPURenderer.js');
                    renderer = new WebGPURenderer({ antialias: true });
                    console.log("WebGPURenderer initialized");
                } else {
                    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                }
            } catch (e) {
                console.error(e);
                showMessage("Renderer Error: " + e.message + ". Falling back to WebGL.");
                renderer = new THREE.WebGLRenderer({ antialias: true });
                isWebGPU = false;
            }

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // WebXR support check
            if (renderer.xr) {
                renderer.xr.enabled = true;
            } else {
                console.warn("XR not available on this renderer instance.");
            }
            
            document.body.appendChild(renderer.domElement);

            // 2.1 Controls Setup
            controls = new OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            // 3. Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(0, 20, 10);
            scene.add(dirLight);

            // 4. Geometry Optimization: InstancedMesh
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ccff, 
                roughness: 0.3, 
                metalness: 0.6 
            });

            mesh = new THREE.InstancedMesh(geometry, material, maxCount);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mesh.count = 0;
            scene.add(mesh);

            // Initial Geometry Load
            addCubes(5000);

            // 5. Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('addGeometry').addEventListener('click', () => addCubes(1000));
            
            // 6. XR Setup
            if (!isWebGPU) {
                setupXR();
            } else {
                xrBtn.innerText = "XR (WebGL ONLY)";
                xrBtn.disabled = true;
            }

            // Start loop
            animate();
        }

        function addCubes(amount) {
            if (currentCount + amount > maxCount) {
                showMessage("Max geometry limit reached (100k cubes).");
                return;
            }

            const offset = currentCount;
            currentCount += amount;

            for (let i = 0; i < amount; i++) {
                const x = (Math.random() - 0.5) * 150;
                const y = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 150;

                dummy.position.set(x, y, z);
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                const s = Math.random() * 0.5 + 0.5;
                dummy.scale.set(s, s, s);
                dummy.updateMatrix();
                
                mesh.setMatrixAt(offset + i, dummy.matrix);
            }

            mesh.count = currentCount;
            mesh.instanceMatrix.needsUpdate = true;
            
            if (mesh.geometry.boundingSphere === null) mesh.geometry.computeBoundingSphere();
        }

        async function setupXR() {
            if ('xr' in navigator) {
                try {
                    const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (isSupported) {
                        xrBtn.innerText = "ENTER WEBXR";
                        xrBtn.onclick = async () => {
                            const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor' ] };
                            try {
                                const session = await navigator.xr.requestSession( 'immersive-vr', sessionInit );
                                renderer.xr.setSession( session );
                                xrBtn.innerText = "XR ACTIVE";
                                xrBtn.disabled = true;
                            } catch (e) {
                                showMessage("XR Error: " + e.message);
                            }
                        };
                    } else {
                        xrBtn.innerText = "VR NOT FOUND";
                        xrBtn.disabled = true;
                    }
                } catch (e) {
                    console.error(e);
                    xrBtn.innerText = "XR ERROR";
                }
            } else {
                xrBtn.innerText = "XR NOT SUPPORTED";
                xrBtn.disabled = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (controls) controls.update();
            renderer.render(scene, camera);
            
            statsEl.innerHTML = `
                FPS: 60+ (GPU Limit)<br>
                Backend: ${isWebGPU ? 'WebGPU' : 'WebGL'}<br>
                Instanced Meshes: ${currentCount}<br>
                Draw Calls: ${renderer.info.render.calls}
            `;
        }
    </script>
</body>
</html>
