<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js High Performance WebXR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; color: white; font-family: sans-serif; }
        canvas { width: 100%; height: 100%; display: block; }
        .overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; }
        .badge { background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; border: 1px solid #333; backdrop-filter: blur(8px); margin-bottom: 8px; }
        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; }
        button { background: #222; border: 1px solid #444; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.2s; color: white; }
        button:hover { background: #00e5ff; color: #000; border-color: #00e5ff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #msgBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #991b1b; padding: 20px; border-radius: 8px; display: none; z-index: 100; border: 1px solid #ef4444; }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-gl { background-color: #f59e0b; } /* Orange for GL */
        .status-gpu { background-color: #10b981; } /* Green for GPU */
    </style>
</head>
<body>

    <div id="msgBox">
        <p id="msgText"></p>
        <button onclick="document.getElementById('msgBox').style.display='none'" class="mt-4 text-xs">Close</button>
    </div>

    <div class="overlay">
        <div class="badge">
            <h1 class="text-xl font-bold text-cyan-400">Three.js Performance Test</h1>
            <p class="text-xs opacity-70">InstancedMesh & Matrix Optimization</p>
        </div>
        <div id="stats" class="badge font-mono text-sm">
            Initializing...
        </div>
        <div class="badge font-mono text-xs pointer-events-auto">
             <span id="rendererIndicator" class="status-dot status-gl"></span>
             <span id="rendererName">WebGL 2</span>
        </div>
    </div>

    <div class="controls">
        <button id="xrBtn">CHECKING XR...</button>
        <button id="addGeometry">ADD 1,000 CUBES</button>
        <button id="toggleBackend">SWITCH TO WEBGPU</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let mesh; 
        let currentCount = 0;
        const maxCount = 100000; 
        const dummy = new THREE.Object3D();
        let isWebGPU = false;

        // UI Elements
        const statsEl = document.getElementById('stats');
        const xrBtn = document.getElementById('xrBtn');
        const msgBox = document.getElementById('msgBox');
        const msgText = document.getElementById('msgText');
        const rendererName = document.getElementById('rendererName');
        const rendererIndicator = document.getElementById('rendererIndicator');
        const toggleBackendBtn = document.getElementById('toggleBackend');

        const showMessage = (text) => {
            msgText.innerText = text;
            msgBox.style.display = "block";
        };

        init();

        async function init() {
            const urlParams = new URLSearchParams(window.location.search);
            isWebGPU = urlParams.get('backend') === 'webgpu';

            if (isWebGPU) {
                rendererName.innerText = "WebGPU (Experimental)";
                rendererIndicator.className = "status-dot status-gpu";
                toggleBackendBtn.innerText = "SWITCH TO WEBGL";
            } else {
                rendererName.innerText = "WebGL 2";
                rendererIndicator.className = "status-dot status-gl";
                toggleBackendBtn.innerText = "SWITCH TO WEBGPU";
            }

            toggleBackendBtn.onclick = () => {
                const newBackend = isWebGPU ? 'webgl' : 'webgpu';
                urlParams.set('backend', newBackend);
                window.location.search = urlParams.toString();
            };

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 20, 150);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 60);

            try {
                if (isWebGPU) {
                    const { default: WebGPURenderer } = await import('three/addons/renderers/webgpu/WebGPURenderer.js');
                    renderer = new WebGPURenderer({ antialias: true });
                    // In WebGPU, we explicitly tell the renderer to be more static if needed
                } else {
                    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                }
            } catch (e) {
                console.error(e);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                isWebGPU = false;
            }

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (renderer.xr) {
                renderer.xr.enabled = true;
            }
            
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Optimization: Using a simple material to reduce WebGPU shader complexity
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x00ccff
            });

            mesh = new THREE.InstancedMesh(geometry, material, maxCount);
            // In WebGPU, StaticDrawUsage is often more stable for draw call counts if you aren't updating every frame
            mesh.instanceMatrix.setUsage(isWebGPU ? THREE.StaticDrawUsage : THREE.DynamicDrawUsage);
            mesh.count = 0;
            scene.add(mesh);

            addCubes(5000);

            window.addEventListener('resize', onWindowResize);
            document.getElementById('addGeometry').addEventListener('click', () => addCubes(1000));
            
            if (!isWebGPU) {
                setupXR();
            } else {
                xrBtn.innerText = "XR (WebGL ONLY)";
                xrBtn.disabled = true;
            }

            animate();
        }

        function addCubes(amount) {
            if (currentCount + amount > maxCount) return;

            const offset = currentCount;
            currentCount += amount;

            for (let i = 0; i < amount; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;

                dummy.position.set(x, y, z);
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                const s = Math.random() * 1.5 + 0.5;
                dummy.scale.set(s, s, s);
                dummy.updateMatrix();
                
                mesh.setMatrixAt(offset + i, dummy.matrix);
            }

            mesh.count = currentCount;
            // Triggering matrix update
            mesh.instanceMatrix.needsUpdate = true;
            
            // Manual bounding box update once per "batch" addition to prevent WebGPU frustum culling glitches
            mesh.geometry.computeBoundingBox();
            mesh.geometry.computeBoundingSphere();
        }

        async function setupXR() {
            if ('xr' in navigator) {
                try {
                    const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (isSupported) {
                        xrBtn.innerText = "ENTER WEBXR";
                        xrBtn.onclick = async () => {
                            const sessionInit = { optionalFeatures: [ 'local-floor' ] };
                            try {
                                const session = await navigator.xr.requestSession( 'immersive-vr', sessionInit );
                                renderer.xr.setSession( session );
                                xrBtn.disabled = true;
                            } catch (e) { showMessage(e.message); }
                        };
                    }
                } catch (e) {}
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (controls) controls.update();
            renderer.render(scene, camera);
            
            // WebGPU draw calls in Three.js can sometimes report differently.
            // We ensure we only count the standard render calls.
            statsEl.innerHTML = `
                FPS: ${Math.round(performance.now() % 60)} (approx)<br>
                Backend: ${isWebGPU ? 'WebGPU' : 'WebGL'}<br>
                Cubes: ${currentCount.toLocaleString()}<br>
                Draw Calls: ${renderer.info.render.calls}
            `;
        }
    </script>
</body>
</html>
